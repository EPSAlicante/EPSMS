######################################################
                      F.A.Q.
######################################################


(0) Prerequisites of Control server
(1) Prerequisites of Mysql server, Nagios server, Munin server , Web server and Openvas server
(2) Preparing a Linux/Unix host to be a 'node'
(3) Preparing a Windows host to be a 'winNode'
(4) What changes make Control server in a outsider?
(5) What changes make Control server in a node?
(6) What changes make Control server in a winNode?
(7) Using a template for a node
(8) Using a template for a distribution
(9) Selecting directories to search executable files
(10) Modify PHP & Angularjs applications
(11) Modify existing Wiki pages
(12) Add a new Wiki page with data from database
(13) Get new information about nodes
(14) How can we add some information in Wiki Server?
(15) How can we consult information directly on database?
(16) Can we add new rows to inventory tables on database?
(17) Can we modify Nagios checks?
(18) Are winNodes (windows nodes) monitored by Nagios?
(19) Are winNodes (windows nodes) monitored by Munin?
(20) Modifying Date and Time of scanning vulnerabilites
(21) Modifying scan profile   
(22) Can we setup a different frequency for a special group of servers?
(23) Can we exclude some hosts of scanning vulnerabilities?
(24) Can we get all vulnerability reports?
(25) Can we modify Ansible timeout (connection time)?


######################################################


(0) Prerequisites of Control server

    Control server has to be a CentOS 6 with python 2.6 installed. It needs ssh connection to all nodes


(1) Prerequisites of Mysql server, Nagios server, Munin server or Web server

    All servers have to be a CentOS 6 with python 2.6 installed 

    Nagios server has to connect to TCP/5666 port (NRPE Nagios) in nodes

    Munin server has to connect to TCP/4949 port (Munin-node) in nodes.

    Openvas server has to connect to all ports in nodes to check vulnerabilities. It also needs TCP/80 permissions to access to atomic repositories (updates.atomicorp.com, www.openvas.org and feed.openvas.org) to install and update openvas software


(2) Preparing a Linux/Unix host to be a 'node'

    If we want a host becomes a node, we have to check and probably made some changes inside:

    * SSH server listenning and permitting Control servers' connections

    * Python 2.X: if python is lower than 2.6 we have to install simplejson package

    * Be sure that host is able to connect to repositories and install software

    Then, we can transform host in a new node, using option '2 Add node' of menu '/etc/ansible/menu.py'


(3) Preparing a Windows host to be a 'winNode'

    If we want a windows host becomes a winNode, we have to configure system to check windows Node and define a connection user and password (option '1 Configure System' of menu '/etc/ansible/menu.py').

    This user will connect to every winNode through WMI (Windows Management Instrumentation). So we need to do some steps in every node:

    * create the defined user and password (in configuration) and add to 'Performance Log Users' group.

    * Add user to security WMI control with 'Remote Enable' permission.

    * Permit acces to WMI in 'Inbound rules' of firewall.


(4) What changes make Control server in a outsider?

    Nothing


(5) What changes make Control server in a node?

    * Bash and sudo will be installed

    * A new user will be created (user used to connect to nodes and execute jobs inside)

    * Created user will be configured to access from Control server without password

    * Sudo will be configured to permit user (created user) execute everything

    * Coreutils, grep, sed, gawk, net-tools, findutils, dmidecode, util-linux will be installed

    * Nagios NRPE & plugins will be installed and configured to be checked (disk Root space free, load and TCP and UDP ports) from Nagios server.

    * TCP wrappers will be configured to permit access from Nagios server

    * Munin node will be installed and configured to be checked from Munin server

    * Iptables or any other firewall will NOT be modified, but access to TCP port 5566 (Nagios NRPE) from Nagios server is needed, and access to TCP port 4949 (Munin node) from Munin server too.


(6) What changes make Control server in a winNode?

    Nothing


(7) Using a template for a node

    System is able to get information on a node about packages needed and commands' paths. But sometimes we want to decide the exact packages and commands' paths for a specific node. In this case we ca do it creating a file with the node's hostname, in 'host_vars' directory. There's a template inside, named 'node.template'. We can use it as example to fill it with variables about packages and commands' paths.


(8) Using a template for a distribution

    The same way, we probably want to decide exact packages and command's paths for a specific distribution and version (Debian 7 for example). In this case we have to create a file with name 'Distribution-Version' (Debian-7 for example) in 'group_vars' directory. There a template inside, named 'Distribution-Version.template'. We can use it as example to fill it with variables about packages and commands' paths.


(9) Selecting directories to search executable files

    Searching executables, getting information about them and making a signature, is a very long job because of big number of executable files in a host.

    So, we can decide where searching executables and where don't do it to reduce time of computing.
    We have to modify two extra variables in '/etc/ansible/config_files/extra.conf': 'pathExes' and 'pathNoExes'

    * pathExes is list of directories where system is going to search executables

    * pathNoExes is a list of directories where system is NOT going to search executables

    Of course, we can decide don't search in any directory, and modify both with an empty string: pathExes: '' and pathNoExes: ''

    Remember always reconfigure system (option 1 in control menu) after modifying extra variables.


(10) Modify PHP & Angularjs applications

     The PHP & Angularjs Applications are really simple, just to use them as templates to make a customized application.

     There's a dokuwiki server with pages about hardware & software inventory to present all this information to user, but if we need more than this, we have to customize the PHP & Angularjs Applications.

     First of all, we should know the meaning of dynamic and static pages. In this case, 'static' doesn't mean the type of language used (like HTML or PHP).  A page is dynamic if the code inside needs to access to Ansible's variables to get their values before showing the page. In other case, the apge will be static.

     -- PHP App --

     There're two simple PHP Applications: 'Simple List /web/simplelist' and 'Update List /web/updates'.

     In PHP Applications there's just one dynamic page: 'db.php.j2' (j2 extension means that this file is using 'jinja2' language to get Ansible's variables). This file code to connect to database, and need values saved in Ansible's variables as: Database server IP and password of inventory user.

     So this code is:

     <?php
     $hostDB="{{ hostMysql }}";
     $nameDB="inventory";
     $userDB="inventory";
     $passwdDB="{{ passwdMysqlInventory }}";
     ?>

     We can see the PHP code with 'jinja2' code ("{{ hostMysql }}" and "{{ passwdMysqlInventory }}") to get values of Ansible's variables: hostMysql and passwdMysqlInventory

     The rest of pages are statics all of them.

     We need to know where the pages are. Statics and dynamics pages are located in differents paths.


     -- Angularjs App --

     There's an Angularjs Aplication: 'Inventory /web/angularjs'.
 
     In Angularjs Application there's no dynamic page because they don't access Database directly, they access to REST API (no need of DB user and password), with database data in JSON format.


     PHP & Angularjs Applications belong to 'web' role. This role have some important tasks to do, as: checking correct installation and configuration of Apache and PHP software, and sincronize PHP & Angularjs pages to Web server. In its directory '/etc/ansible/roles/web' we find three important directories:

     * 'tasks', with code to check software and sincronize PHP & Angularjs pages

     * 'files', with static pages in 'files/var/www/web' and subdirectories

     * 'templates', with dynamic pages in 'templates/var/www/web' and subdirectories

     Sincronization task get the values of Ansible's variables and send updated pages to Web server under '/var/www/web'.

     We MUST NOT modify pages in Web server, because they will be updated in the next sincronization and we'll lose all changes. We have to change web pages in Control Server and wait for next sincronization to have Web server updated, or we can force a sincronization calling 'web.yml' playbook manually typing:

     ansible-playbook /etc/ansible/web.yml -t web

     This playbook (with 'web' label) will check installation and configuration of software and sincronizes web pages (PHP & Angularjs Applications).


(11) Modify existing Wiki pages

     Wiki Server is made with Dokuwiki software and show all the information about nodes (software and hardware) and outsiders (just TCP ports) with historic old versions.

     If we want to change pages with no new information (just changing the output format), we have to modify dokuwiki code.

     We MUST NOT modify pages in Wiki server, because they will be updated in the next web playbook execution and we'll lose all changes. We have to change dokuwiki pages in Wiki Server and wait for next web playbook execution to have Wiki server updated, or we can force an update calling 'web.yml' playbook manually typing:

     ansible-playbook /etc/ansible/web.yml -t wiki

     This playbook (with 'wiki' label) will check installation and configuration of dokuwiki software and sincronizes wiki pages.
 
     Wiki pages are in different places, depending on the role that make them (playbooks calls roles code). Almost every page are made by 'node' role except:

     * main page 'servers' (it shows list of servers: nodes and outsiders)

     * 'last 100 changes' pages 'hostname-hostslast' (they show last 100 changes in 'hostname' server)

     * 'external TCP ports check' pages 'hostname-portsext' (they show TCP ports clicking in 'hostname' link for outsiders)

     All of these are made by 'outsider' role.

     Pages made by 'node' role are located in '/etc/ansible/roles/node/templates/var/lib/dokuwiki/data/pages/inventory' directory.

     Pages made by 'outsider' role are located in '/etc/ansible/roles/outsider/templates/var/lib/dokuwiki/data/pages/inventory' directory.

     All pages have 'j2' extension. They have 'jinja2' code inside used to get information about Ansible's variables. In this case information is not just about global variables, 'outsider' role generates new variables about network scanning and 'node' role generates variables about software and hardware information.

     We can modify dokuwiki code to change output format or add/delete/change existing Ansible's variables with information.


(12) Add a new Wiki page with data from database

     There are some pages with information from database. These pages get more information than the other pages (information about nodes or outsiders), they add information from database to show historic information to user.

     These are the steps we have to do to make these kind of wiki pages:

     * Add a new task, calling 'db_facts' script in a task file ('.yml' files in 'tasks' directory of every role).

       For example, if we want to make a new wiki page about nodes basic information (not about packages or executables), we'll modify '/etc/ansible/roles/node/tasks/dataDB.yml'.

       New task could be like:

       - name: Task name
         action: db_facts hostMysql="{{ hostMysql }}" and passwd="{{ passwdMysqlInventory }}" label="DB query's name"
query="Select Field1, FieldN from Table where Server='{{ inventory_hostname }}'"
         delegate_to: ${hostMysql} 

       Notes:

       + 'label' is the query's name. Very important because it make a variables list with this name, so we'll have to use it to call variables inside page's code.

       + We can use every valid SQL query. Field's names are very important (of course we can use 'AS' SQL label to rename them) because they will be attributes' names of variables to call them inside page's code.

       + A very used Ansible's variable to make SQL query filters is {{ inventory_hostname }} (curly braces is 'jinja2' code to get value of Ansible's variable 'inventory_hostname'). This way we could make a SQL query for every node.  


     * After making the query, we have to prepare wiki page using new variables. We'll place wiki template in '/etc/ansible/roles/node/templates/var/lib/dokuwiki/data/pages/inventory' with whathever name, but it needs '.txt.j2' extension (dokuwiki files have 'txt' extension and template with jinja2 code have 'j2' extension). So this file will have jinja2 code to get variables' values (made with SQL query) and dokuwiki code will make an output format to show data. There are some examples of wiki pages with data from database in 'node' and 'outsider' roles.

     * Then we have to create a new task in the same task file (after 'db_facts' task), to copy wiki file to Wiki server with 'tmp' extension (and without 'j2' extension) and calling revision control system script '/usr/share/dokuwiki/bin/dwpage.php'. For example, if our wiki file is called 'host-prueba.txt.j2', task will be:

       - name: Copy host-prueba.txt from DB (in Wiki Master)
         template: src=var/lib/dokuwiki/data/pages/inventory/host-prueba.txt.j2 dest=/var/lib/dokuwiki/data/pages/inventory/.{{ inventory_hostname|lower }}-prueba.txt.tmp owner=root group=root mode=0644
         delegate_to: ${hostWeb}

       - name: Commit changes of host-prueba.txt from DB & update (in Wiki Server)
         shell: /usr/bin/php /usr/share/dokuwiki/bin/dwpage.php -m "Ansible check at $(date '+%Y-%m-%d %H:%M:%S')" commit /var/lib/dokuwiki/data/pages/inventory/.{{ inventory_hostname|lower }}-prueba.txt.tmp inventory:{{ inventory_hostname|lower }}-prueba
         delegate_to: ${hostWeb}

     * We should keep in mind that we need a link in some page to our new page. So we have to add dokuwiki code to make a link '[[ linked page | text ]]', in template where we want to call or new page. Templates are located in '/etc/ansible/roles/node/templates/var/lib/dokuwiki/data/pages/inventory' directory, except main Wiki page 'servers', located in '/etc/ansible/roles/outsider/templates/var/lib/dokuwiki/data/pages/inventory/servers.txt.j2' and a few more generated by 'outsider' role, about outter scannings (in the same directory that 'servers' page).

     * Finally, we can test that everything works correctly. So, we have to execute option '7 Get data from node(s)', and if playbook ends without errors, we can check wiki page, accesing to URL 'https://WebServer/wiki'.


(13) Get new information about nodes

     Thats the longest modification. It's not difficult but it takes some time.

     We need a script to get information from nodes, some tables on database to save new information, templates with SQL operation to save information on database, wiki template to show information on Wiki server, and Ansible tasks to manage every step.
 
     For example, if we want to get information about kernel parameters in '/etc/sysctl.conf' file, we have to do the next steps:

     * Create new script in '/etc/ansible/scripts' directory, to get new information, called site_facts.sysctl.py or something similar. Of course, We can modify '/etc/ansible/scripts/site_facts.py' to add a new function to get info about sysctl.
       We can use any language to make new script. If we use python we'll be sure that python is on every node because python is a prerequisite to be a node. But we can use any other language, and add a new task to install language binary before execute the script.
       Script has to return information in JSON format. We can watch other scripts (for example 'site_facts.py') to learn about output format.

     * We can test it, executing script by command line and analyzing information and a correct JSON format. If script works correctly, we have to release new script in Ansible. We can do it linking from '/usr/share/ansible/site_facts.sysctl.py' to our script in '/etc/ansible/scripts/site_facts.sysctl.py', but not directly (by command line), we have to add a new task to 'ansible' role, modifying '/etc/ansible/roles/ansible/tasks/config.yml' task file, and adding:

       - name: Link /[pathAnsibleLibrary]/site_facts.sysctl -> /[pathAnsible]/scripts/site_facts.sysctl.py
         file: path={{ pathAnsibleLibrary }}/site_facts.sysctl state=link src={{ pathAnsible }}/scripts/site_facts.sysctl.py force=yes

       Script will be released in the next Ansible configuration (execution of '/etc/ansible/ansible.yml' playbook), but we can do it immediately, executing the playbook:

       ansible-playbook /etc/ansible/ansible.yml -t config

     * Now we have to create a table called 'sysctl' on database to save new information. We don't create table directly, we have to modify the database creation file '/etc/ansible/roles/msyql/files/root/inventory/createTables.sql' (a SQL file to create all the tables on 'inventory' database).

       Database will be modified in the next execution of 'mysql' role, but we can do it immediately, executing the playbook:

       ansible-playbook /etc/ansible/mysql.yml

     * Then we have to add a new task in '/etc/ansible/roles/node/tasks/dataDB.yml' (task file of 'node' role to get data from nodes) to execute the new script 'site_facts.sysctl.y':

       - name: Getting sysctl data from nodes
         action: site_facts.sysctl

       We have to add task in the beginning of task file (after task that executes 'site_facts') to have the new information available for the rest of file.

     * Now, we have information in Ansible's variables and database ready, so we have to save data on database. This way, we have to create 'jinja2' templates with SQL operations to INSERT or MODIFY data.

       We can learn 'jinja2' to create SQL file or analyze other SQL file of '/etc/ansible/roles/node/templates/root/inventory/nodes' directory, copy as 'node_dataSysctl.sql.j2' in the same directory and modify. Last SQL operations: 'END-CHECK_' and 'END-UPDATE_' are used to nullify rows not detected. We'll use a pair of them for any table.

       We have to change another SQL file, '/etc/ansible/roles/outsider/templates/root/inventory/POST_ending.sql.j2' adding a pair of 'END-CHECK_' and 'END-UPDATE_' for any table, at the end of the file. This file is used to nullify all rows of a server when server is down (when network scanning script 'net_facts.py' doesn't detect the server anymore).

     * Then we have to modify task file '/etc/ansible/roles/node/tasks/dataDB.yml', looking for 'Generate sql files (in Mysql Server)' task, adding a new template called 'sysctl' at the botton of list 'with_items:' 

     * We can test that everything works correctly before add the wiki page. So, we have to execute option '7 Get data from node(s)', and if playbook ends without errors, we can check database to find new information with 'PhpMyAdmin' (Mysql management software), accesing to URL 'https://WebServer/phpmyadmin' (user 'inventory' and password introduced at configuation time).

     * Now, it's time to create new wiki page. Steps are similar we did to create SQL file. Now we need to create a wiki template with 'jinja2' code to access Ansible's variables and 'dokuwiki' code to design page. The simplest way is to copy another wiki template from '/etc/ansible/roles/node/templates/var/lib/dokuwiki/data/pages/inventory' directory as 'host-sysctl.txt.j2' in the same directory, and change 'jinja2' with new variables ('jinja2' code is always between curly braces or '{%' and '%}' symbols) and 'dokuwiki' code with new design.

     * Then we have to modify task file '/etc/ansible/roles/node/tasks/dataDB.yml' again to generate new wiki page. We have to look for 'Copy host-items.txt (in Wiki Master)' task (copy generated wiki page in server)  and 'Commit changes of host-items.txt & update (in Wiki Server)' task (put old page to historic versions and is updated with new page), adding a new template called 'sysctl' at the bottom of list 'with_items:'.

     * We should keep in mind that we need a link in some page to our new page. So we have to add dokuwiki code to make a link '[[ linked page | text ]]', in template where we want to call or new page. Templates are located in '/etc/ansible/roles/node/templates/var/lib/dokuwiki/data/pages/inventory' directory, except main Wiki page 'servers', located in '/etc/ansible/roles/outsider/templates/var/lib/dokuwiki/data/pages/inventory/servers.txt.j2' and a few more generated by 'outsider' role, about outter scannings (in the same directory that 'servers' page).

     * Finally, we can test again that everything works correctly. So, we have to execute option '7 Get data from node(s)' again, and if playbook ends without errors, we can check wiki page, accesing to URL 'https://WebServer/wiki'.


(14) How can we add some information in Wiki Server?

     Wiki Server main page 'servers' shows a list of servers: 'nodes', 'winNodes' and 'outsiders'. This list has a fiels named 'notes' to add some information about servers.

     This information won't be saved on database, just in Wiki pages.


(15) How can we consult information directly on database?

     Obviouly we can do it with every mysql client, but we have to know the list of IP's permitted to access (this list is defined on configuration time).

     Furthermore, we always can use PhpMyAdmin software in Web server, in URL https://web_server/phpmyadmin , a grahical mysql client.

     We just need enter mysql user: can be 'inventory' to access 'inventory' database (all data is saved in this database) or 'root' to manage database. Password of both users are defined in configuration time.


(16) Can we add new rows to inventory tables on database?

     Yes, all tables on 'inventory' database have a field named 'auto' (boolean type). Every data made by system are saved on databse with field 'auto' as 'true', and system just recognise data with 'auto' as 'true'.

     So we can add every row we want. If we save data with 'auto' as 'true', system will recognise as owner of data (we can see new data on wiki server and PHP Application). 

     But if we add data with 'auto' as 'false' , system won't recognise it (they won't appear on wiki server or PHP Application), but we can modify PHP Application to admit these data, or make SQL queries to get new data.


(17) Can we modify Nagios checks?

     Of course, but we have to know what kind of checks are defined by system (we can't change these checks, because system always update them).

     For every host ('node' or 'outsider') there are some external checks (directly check, without NRPE) defined in Nagios server, in a file named '/etc/nagios3/conf.d/hostname_nagios3.cfg'. Inside Nagios defines 'host' and an external check for every TCP port (with check_tcp plugin).

     We can't modify these 'hostname_nagios3.cfg' files because they will be updated in every execution of outsider.yml playbook, but we can create another file (named hostname_extra_nagios3.cfg for example) and define inside every external check we want for 'hostname' host.

     For every node (nodes have installed Nagios NRPE, so we can do internal checks) Nagios server defines some NRPE check (with check_nrpe plugin) in a file named '/etc/nagios3/conf.d/node_hostname_nagios3.cfg'. 

     On top of file there's a 'check_nrpe' with a label 'check_Ansible_load' to check node's Load (this label have to be defined in Nagios NRPE of nodes).

     After 'check_Ansible_load' there's another 'check_nrpe' with label 'check_Ansible_diskRoot' to check free space on root disk.

     Finally there're some 'check_nrpe', each of them for every TCP & UDP port, with a label as 'check_portTCP_numberPort' or 'check_portUDP_numberPort' (depending on kind of port, TCP or UDP). 

     Every node has Nagios NRPE installed. In '/etc/nagios/nrpe.d' directory there're three file: 

     * nrpe_diskRoot.cfg

       This file includes a command with 'check_Ansible_diskRoot' label and calls 'check_disk' plugin to check free space in root disk.

     * nrpe_load.cfg

       This file includes a command with 'check_Ansible_load' label and calls 'check_load' plugin to check Load.

     * nrpe_ports.cfg

       This file includes some commands with 'check_portTCP_portNumber' and 'check_portUDP_portNumber' labels and call 'check_listen_tcp_udp.sh' plugin to check TCP & UDP ports.

     We can't modify these 'nrpe_*' files because they will be updated in every execution of nodes.yml playbook, but we can create another file named 'nrpe_whateverCheck.cfg' to add new NRPE checks (don't forget add a 'check_nrpe' in Nagios server with the same label).

     If we want to modify something in defined external checks in Nagios server, we have to modify '/etc/ansible/roles/outsider/templates/etc/nagios3/conf.d/out_nagios3.cfg.j2' template (it has 'jinja2' code inside). NEVER change files directly in Nagios server.

     If we want to modify something in defined internal checks in nodes, we have to modify '/etc/ansible/roles/node/templates/etc/nagios3/conf.d/node_nagios3.cfg.j2' template (to modify 'check_nrpe' calls from Nagios server) and '/etc/ansible/roles/node/templates/etc/nagios/nrpe.d/nrpe_*' templates (to modify internals 'check_*' in nodes). NEVER change files directly in nodes (Nagios NRPE).


(18) Are winNodes (windows nodes) monitored by Nagios?

     Yes, winNodes are monitored but just externally as outsiders. They aren't monitored internally monitored (with 'check_nrpe') because they don't have Nagios NRPE installed. 

     If we want to install Nagios NRPE in winNodes, we have to do it manually. We can get a Nagios NRPE for windows as 'winrpe' ('https://www.itefix.net/winrpe') or 'Nsclient++' ('www.nsclient.org') and configure it.


(19) Are winNodes (windows nodes) monitored by Munin?

     No, winNodes aren't monitored by Munin because they don't have Munin node installed.

     If we want to install Munin node in winNodes, we have to do it manually. We can get a Munin node for windows as 'munin-node-win32' ('http://sourceforge.net/projects/munin-nodewin32') and configure it.


(20) Modifying Date and Time of scanning vulnerabilites

     At configuration time we can choice frequency of scanning vulnerabilities (in months). By default scannings will start at 02:30 of first day of month.

     We can change minutes, hours, day, even weekday of starting, configuring extra parameters with 'Configure Extra Variables (option 2 in control menu). Script will ask: 'Openvas Crontab' to define minutes, hours, day or weekday at crontab.



(21) Modifying scan profile

     By default Openvas use 'Full and Fast' scan profile. 

     We can change it configuring extra parameters with 'Configure Extra Variables (option 2 in control menu). Script will ask: 'Config Scan Openvas' and available options are: 'Discovery', 'Host Discovery', 'System Discovery', 'Full and fast', 'Full and fast ultimate', 'Full and very deep' and 'Full and very deep ultimate'.


(22) Can we setup a different frequency (for scanning vulnerabilities) for a special group of servers?

     Yes, if we want to scan vulnerabilities on a small group of servers with a different frequency (usually with a higher frequency), we can do it configuring extra parameters with 'Configure Extra Variables (option 2 in control menu). Script will ask: 'Do you want to create Openvas Special Group?'. If we answer 'y', script will ask some questions to configure group:

     * 'Openvas Special Servers List' to define 'special' servers (a list of servers separated by whitespaces). 

     * 'Openvas Special Group Crontab' to define frequency checks, setting crontab variables: minutes, hours, day, month and weekday.


(23) Can we exclude some hosts of scanning vulnerabilities?

     Yes, if we want to avoid scanning vulnerabilities in a group of servers, we can specify them configuring extra parameters with 'Configure Extra Variables (option 2 in control menu). Script will ask: 'Exclude Openvas Servers List' to define 'excluded' servers (a list of servers separated by whitespaces).


(24) Can we get all vulnerability reports?

     Of course, all reports are saved in 'openvas' directory of Web server. In 'openvas' directory there are a subdirectory for every server scanned. All reports are saved as 'serverName-DateTime.html', 'serverName-DateTime.pdf', 'serverName-DateTime.txt' and 'serverName-DateTime.xml' in their directory.


(25) Can we modify Ansible timeout (connection time)?

     Sometimes netload is high and Ansible's errors are produced tryng to connect to nodes. We can increase SSH timeout (just for Ansible software) modifying value of 'timeout' variable in 'ansible.cfg' file.


######################################################
